#include "GraphicsManager/GraphicsManager.hpp"
#include "HopfieldSimulator/CoherenceSetPattern.hpp"
#include "HopfieldSimulator/HopfieldNetwork.hpp"
#include "HopfieldSimulator/HopfieldSimulator.hpp"
#include "ImGuiFileDialog/ImGuiFileDialog.h"
#include <atomic>
#include <chrono>
#include <complex>
#include <functional>
#include <future>
#include <iomanip>
#include <iostream>
#include <stdexcept>
#include <string>

template <typename neurons_type, typename matrix_type>
int run_application(int, char **) {

  try {

    /********************START OF VARIABLE LIST********************/

    GraphicsManager graphics; // manages the IMGUI and SDL graphics libraries
    Comp<neurons_type, matrix_type>
        comp; // allows for easy creation of grids and graphs
    HS::HopfieldSimulator<neurons_type, matrix_type>
        hs;               // the object we can use to customize our state
    int pixel = 8;        // the number of pixels the class should have
    int pixel_slider = 8; // the pixels indicated by the slider
    float noise =
        0.1f; // the noise that will be generated by the "Corrupt" button
    size_t index = 0;    // index of the pattern to display
    bool running = true; // indicates if the program is running
    bool is_operation_in_progress =
        false;              // if true, prevents the user from pressing another
                            // computationally intensive button
    bool hebb = true;       // boolean to choose the training type
    bool trained = false;   // verifies if the patterns have been trained
    bool showWindow = true; // indicates whether to show the initial screen
    std::future<void> thread; // launches complex operations in parallel
    static char pathBuffer[256] =
        "trainings/nameNetwork"; // default name for saving training files
    std::atomic<float> statusTrain =
        0.0f; // indicates the loading percentage of the training
    std::atomic<float> statusEvolve =
        0.0f; // indicates the loading percentage of the evolution
    std::vector<std::atomic<float> *> kill = {
        &statusTrain,
        &statusEvolve}; // pointers to the states so that the program
    // can access them and interrupt costly processes

    /// First FileDialog
    FileDialogHelper fdh{"firstDialog", "Open Image(s)",
                         ".png,.jpg,.jpeg,.bmp,.gif",
                         25}; // file dialog for opening images
    fdh.onSuccess = [&](const std::string &filePath) {
      hs.emplace_pattern(filePath, pixel, pixel);
    };
    fdh.onDialogClose = [&] {
      showWindow = true;
    }; // when I close the dialog, I want the main window to be visible

    /// Second FileDialog
    FileDialogHelper fdh2{"seccondDialog", "Open Training", ".training",
                          1}; // file dialog for opening a training file
    fdh2.onSuccess = [&](const std::string &filePath) {
      //// a training file has two integers representing the two dimensions
      /// (width and height) of the patterns it can solve and the weight matrix
      int numRows = 0;
      int numColumns = 0;
      std::vector<matrix_type> matrix;

      // function that returns the data
      comp.setElementsByFile(filePath, &numRows, &numColumns, &matrix);
      if (numRows != numColumns) {
        /// the main application is built to be square
        throw std::runtime_error("Invalid matrix dimensions: the "
                                 "training must consist of square patterns");
      }

      pixel = numRows;                             // assign the obtained data
      hs.setTraining(numRows, numColumns, matrix); // assign the training
      trained = true; // confirm that it has been trained
    };
    fdh2.onDialogClose = [&] {
      showWindow = true;
    }; // when I close the dialog, I want the main window to be visible

    /*********END OF VARIABLE LIST***************/

    while (running) {

      running = graphics.beginFrame(kill);

      if (running) {

        // thread management
        if (is_operation_in_progress) {
          if (thread.valid() && thread.wait_for(std::chrono::seconds(0)) ==
                                    std::future_status::ready) {
            thread.get();
            is_operation_in_progress = false;
            statusTrain = 1.0f;
            statusEvolve = 1.0f;
          }
        }
        // Configure graphics
        graphics.config();
        ImGui::SetNextWindowCollapsed(!showWindow, ImGuiCond_Always);

        /****************START OF WINDOW CREATION****************/
        /*************start controllable parameters***********/

        ImGui::Begin("Hopfield Network");

        ImGui::Text("Hopfield Network control");
        ImGui::Text("Parameters:");
        ImGui::BeginDisabled(is_operation_in_progress);
        if (ImGui::SliderInt("Pixel Per Row", &pixel_slider, 2, 64)) {

          if (hs.size() < 9) {
            pixel = pixel_slider;
            trained = false;
            hs.regrid(pixel, pixel);
          }
        }
        ImGui::EndDisabled();

        if (hs.size() > 8) {
          ImGui::BeginDisabled(is_operation_in_progress);
          {
            if (ImGui::Button("Apply Grid")) {
              pixel = pixel_slider;
              trained = false;
              hs.regrid(pixel, pixel);
            }
          }
          ImGui::EndDisabled();
        }

        ImGui::SliderFloat("Noise", &noise, 0.0f, 1.0f);
        ImGui::Separator();
        /************start controllable parameters****************/
        /*button to open images*******************/
        ImGui::BeginDisabled(is_operation_in_progress);
        {
          if (ImGui::Button("Open Images")) {
            showWindow = false;
            fdh.open();
          }
          fdh.render();
        }
        if (ImGui::Button("Generate Image")) {
          hs.generatePattern(noise, pixel, pixel);
          index = hs.size() > 0 ? hs.size() - 1 : 0;
        }
        ImGui::EndDisabled();

        ImGui::Separator();
        /***************start training section**********/
        /*button to train the network*************/
        ImGui::BeginDisabled(is_operation_in_progress);
        if (ImGui::Button(hebb ? "Hebb" : "Pseudoinverse")) {
          hebb = !hebb;
        }
        ImGui::EndDisabled();

        ImGui::SameLine();
        ImGui::BeginDisabled(is_operation_in_progress);
        {
          if (ImGui::Button("Train Hopfield Network")) {
            trained = true;
            is_operation_in_progress = true;
            statusTrain.store(0.0f, std::memory_order_relaxed);

            // Start trainNetwork in a separate thread using std::async
            thread = std::async(std::launch::async, [&]() {
              // This is a lambda that will be executed in the new thread
              if (hebb) {
                hs.trainNetworkHebb(&statusTrain);
              } else {
                hs.trainNetworkWithPseudoinverse(&statusTrain);
              }
            });
          }
        }
        ImGui::EndDisabled();
        ImGui::SameLine();

        /*button to save a network**************************/
        ImGui::BeginDisabled(is_operation_in_progress);

        if (ImGui::Button("Save Trained Network")) {
          ImGui::OpenPopup("Save Dialog");
        }
        ImGui::EndDisabled();

        if (ImGui::BeginPopupModal("Save Dialog", NULL,
                                   ImGuiWindowFlags_AlwaysAutoResize)) {

          ImGui::Text("Save the Hopfield Network trained .\nSpecificy the"
                      "saving path (without extension).\n");
          ImGui::Separator();

          ImGui::InputText("Saving path", pathBuffer, sizeof(pathBuffer));
          ImGui::Spacing();

          if (ImGui::Button("Save", ImVec2(120, 0))) {
            hs.saveFileTraining(pathBuffer);
            ImGui::CloseCurrentPopup();
          }

          ImGui::SetItemDefaultFocus();
          ImGui::SameLine();

          if (ImGui::Button("Cancel", ImVec2(120, 0))) {
            ImGui::CloseCurrentPopup();
          }

          ImGui::EndPopup();
        }
        /*button to load a training************************/
        ImGui::SameLine();
        ImGui::BeginDisabled(is_operation_in_progress);
        {
          if (ImGui::Button("Open Training")) {
            showWindow = false;
            fdh2.open();
          }
          fdh2.render();
        }
        ImGui::EndDisabled();
        /*button to reset the training and his
         * status***************************/
        ImGui::SameLine();
        if (ImGui::Button("Stop!")) {
          statusTrain.store(-1.0f, std::memory_order_release);
        }
        ImGui::SameLine();
        ImGui::Text("Loading: %.1f/100.0",
                    100.0f * statusTrain.load(std::memory_order_acquire));

        /************end training section****************/
        /****************start of next&previous section**************/

        ImGui::Separator();
        if (hs.size() > 0) {

          ImGui::Text("You are watching the pattern number  %ld", index + 1);

          if (ImGui::Button("<")) {
            if (index > 0) {
              hs.clear(index);

              index--;
            }
            ImGui::End();
            graphics.endFrame();

            continue;
          }
          ImGui::SameLine();
          if (ImGui::Button(">")) {
            if (index < hs.size() - 1) {
              hs.clear(index);
              index++;
            }
            ImGui::End();
            graphics.endFrame();

            continue;
          }

          /*check of the dimensions*/
          ImGui::BeginDisabled(is_operation_in_progress);
          if (ImGui::Button("Check Dimensions")) {
            trained = hs.checkDimension();
          }
          ImGui::EndDisabled();

          ImGui::Separator();

          /****************end of next&previous section***********/
          /*****************start of the three pattern
           * drawings******************/
          /*original pattern************/

          ImGui::BeginGroup();
          ImGui::BeginDisabled(is_operation_in_progress);
          if (ImGui::Button("Delete")) {
            hs.removePattern(index);
            if (hs.size() == 0) {
              index = -1;
            } else if (index > 0) {
              index--;
            }
            index = 0;
            ImGui::EndGroup();
            ImGui::EndDisabled();
            ImGui::End();
            graphics.endFrame();

            continue;
          }
          ImGui::EndDisabled();

          const auto &current_pattern_container = hs.getPatterns()[index];
          ImGui::Text("Original pattern:");
          const std::vector<neurons_type> &training_data =
              current_pattern_container->getTrainingPatternVector();
          comp.drawGrid(training_data, pixel, pixel, "training_pattern");
          ImGui::EndGroup();
          /*corrupted pattern********************************/

          ImGui::SameLine();
          ImGui::BeginDisabled(is_operation_in_progress);
          ImGui::BeginGroup();
          if (ImGui::Button("Corrupt")) {
            hs.corruptPattern(index, noise);
          }
          ImGui::EndDisabled();

          ImGui::Text("Corrupt pattern:");
          const std::vector<neurons_type> &noisy_data =
              current_pattern_container->getNoisyPatternVector();

          comp.drawGrid(noisy_data, pixel, pixel, "noisy_pattern",
                        [&](int hovered_index) {
                          hs.cyclePixelStateOnPattern(index, hovered_index);
                        });
          ImGui::EndGroup();

          ImGui::SameLine();
          /*evolving pattern********************************/

          ImGui::BeginGroup();

          ImGui::BeginDisabled(!trained || is_operation_in_progress);
          {
            if (ImGui::Button("Evolve")) {
              statusEvolve.store(0.0f, std::memory_order_relaxed);
              // Start trainNetwork in a separate thread using std::async
              thread = std::async(std::launch::async, [&]() {
                // This is a lambda that will be executed in the new thread
                hs.resolvePattern(index, &statusEvolve);
              });
            }
          }
          ImGui::EndDisabled();

          ImGui::SameLine();
          ImGui::Text("Loading: %.1f/100.0",
                      100.0f * statusEvolve.load(std::memory_order_acquire));
          ImGui::SameLine();

          if (ImGui::Button("Stop")) {
            statusEvolve.store(-1.0f, std::memory_order_release);
          }
          ImGui::Text("Evolving pattern:");
          const std::vector<neurons_type> &evolving_data =
              current_pattern_container->getEvolvingPatternVector();

          comp.drawGrid(evolving_data, pixel, pixel, "evolving_pattern");
          ImGui::EndGroup();

          ImGui::SameLine();

          /*start drawing of the energy plot ******************/

          ImGui::BeginGroup();
          const std::vector<float> &energy =
              current_pattern_container->getEnergy();
          comp.drawPlot(energy);

          ImGui::EndGroup();
        }
        // /*****************end drawing of the three pattern+energy
        // plot*************/
        // /***************END OF WINDOW CREATION******************/

        ImGui::End();
      }

      graphics.endFrame();
    }

  } catch (const std::runtime_error &e) {
    throw std::logic_error("Critical error: " + std::string(e.what()));

    return 1;
  }

  return 0;
}